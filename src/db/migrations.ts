import { Pool } from "pg";
import { createClient } from "@supabase/supabase-js";
import dotenv from "dotenv";

dotenv.config();

// Supabase connection (for reference)
const supabaseUrl = process.env.SUPABASE_URL || "";
const supabaseKey = process.env.SUPABASE_ANON_KEY || "";
const supabase = createClient(supabaseUrl, supabaseKey);

// Direct PostgreSQL connection for migrations
const pool = new Pool({
  host: process.env.POSTGRES_HOST,
  database: process.env.POSTGRES_DATABASE,
  user: process.env.POSTGRES_USER,
  password: process.env.POSTGRES_PASSWORD,
  port: parseInt(process.env.POSTGRES_PORT || "5432"),
  ssl: { rejectUnauthorized: false },
  connectionTimeoutMillis: 10000,
  query_timeout: 10000,
});

console.log('Attempting to connect to database:', {
    host: process.env.POSTGRES_HOST,
    database: process.env.POSTGRES_DATABASE,
    user: process.env.POSTGRES_USER,
    port: process.env.POSTGRES_PORT
  });
  
// Migration functions
export async function createTables() {
  const client = await pool.connect();

  try {
    // Start transaction
    await client.query("BEGIN");

    // Create migrations table if it doesn't exist
    await client.query(`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `);

    // Check if tables exist
    const { rows } = await client.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_name IN ('rate_history', 'all_bananacrystal_rates');
    `);

    const existingTables = new Set(rows.map(row => row.table_name));

    if (!existingTables.has('rate_history')) {
      console.log("Creating rate_history table...");

      // Create rate_history table
      await client.query(`
        CREATE TABLE rate_history (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          from_currency VARCHAR(3) NOT NULL,
          to_currency VARCHAR(3) NOT NULL,
          banana_crystal_rate DECIMAL(20,6) NOT NULL,
          confidence DECIMAL(5,2) NOT NULL,
          volatility_index DECIMAL(10,2) NOT NULL,
          is_stationary BOOLEAN NOT NULL,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
        );

        -- Create index for faster querying
        CREATE INDEX idx_rate_history_currency_pair 
        ON rate_history(from_currency, to_currency);

        -- Create index for timestamp-based queries
        CREATE INDEX idx_rate_history_created_at 
        ON rate_history(created_at DESC);

        -- Record migration
        INSERT INTO migrations (name) 
        VALUES ('create_rate_history_table');
      `);

      console.log("Rate history table created successfully!");
    } else {
      console.log("Rate history table already exists.");
    }

    if (!existingTables.has('all_bananacrystal_rates')) {
      console.log("Creating all_bananacrystal_rates table...");

      await client.query(`
        CREATE TABLE all_bananacrystal_rates (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          currency VARCHAR(3) NOT NULL,
          buy_rate DECIMAL(20,6) NOT NULL,
          sell_rate DECIMAL(20,6) NOT NULL,
          confidence DECIMAL(5,2) NOT NULL,
          volatility_index DECIMAL(10,2) NOT NULL,
          is_stationary BOOLEAN NOT NULL DEFAULT false,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
        );

        -- Create index for faster querying
        CREATE INDEX idx_all_bananacrystal_rates_currency 
        ON all_bananacrystal_rates(currency);

        -- Create index for timestamp-based queries
        CREATE INDEX idx_all_bananacrystal_rates_created_at 
        ON all_bananacrystal_rates(created_at DESC);

        -- Record migration
        INSERT INTO migrations (name) 
        VALUES ('create_all_bananacrystal_rates_table');
      `);

      console.log("All BananaCrystal rates table created successfully!");
    } else {
      console.log("All BananaCrystal rates table already exists.");
    }

    // Commit transaction
    await client.query("COMMIT");
  } catch (error) {
    // Rollback in case of error
    await client.query("ROLLBACK");
    console.error("Error during migration:", error);
    throw error;
  } finally {
    // Release client back to pool
    client.release();
  }
}

// Function to drop tables (useful for testing/development)
export async function dropTables() {
  const client = await pool.connect();

  try {
    await client.query("BEGIN");

    await client.query(`
      DROP TABLE IF EXISTS rate_history CASCADE;
      DROP TABLE IF EXISTS all_bananacrystal_rates CASCADE;
      DROP TABLE IF EXISTS migrations CASCADE;
    `);

    await client.query("COMMIT");
    console.log("Tables dropped successfully!");
  } catch (error) {
    await client.query("ROLLBACK");
    console.error("Error dropping tables:", error);
    throw error;
  } finally {
    client.release();
  }
}

// Function to add recommended rate columns to all_bananacrystal_rates table
export async function addRecommendedRateColumns() {
  const client = await pool.connect();

  try {
    // Start transaction
    await client.query("BEGIN");

    // Check if columns exist
    const { rows } = await client.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_name = 'all_bananacrystal_rates' AND column_name IN ('recommended_buy_rate', 'recommended_sell_rate');
    `);

    const existingColumns = new Set(rows.map(row => row.column_name));

    if (!existingColumns.has('recommended_buy_rate')) {
      console.log("Adding recommended_buy_rate column to all_bananacrystal_rates table...");

      // Add recommended_buy_rate column
      await client.query(`
        ALTER TABLE all_bananacrystal_rates
        ADD COLUMN recommended_buy_rate DECIMAL(20,6);
      `);

      console.log("recommended_buy_rate column added successfully!");
    } else {
      console.log("recommended_buy_rate column already exists.");
    }

    if (!existingColumns.has('recommended_sell_rate')) {
      console.log("Adding recommended_sell_rate column to all_bananacrystal_rates table...");

      // Add recommended_sell_rate column
      await client.query(`
        ALTER TABLE all_bananacrystal_rates
        ADD COLUMN recommended_sell_rate DECIMAL(20,6);

        -- Record migration
        INSERT INTO migrations (name) 
        VALUES ('add_recommended_rate_columns');
      `);

      console.log("recommended_sell_rate column added successfully!");
    } else {
      console.log("recommended_sell_rate column already exists.");
    }

    // Commit transaction
    await client.query("COMMIT");
  } catch (error) {
    // Rollback in case of error
    await client.query("ROLLBACK");
    console.error("Error during migration:", error);
    throw error;
  } finally {
    // Release client back to pool
    client.release();
  }
}

// Migration script
async function runMigrations() {
  try {
    await createTables();
    await addRecommendedRateColumns();
    console.log("Migrations completed successfully!");
  } catch (error) {
    console.error("Migration failed:", error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

// Execute migrations if this file is run directly
if (require.main === module) {
  runMigrations();
}

async function runMigrationsWithRetry(retries = 3): Promise<void> {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      await createTables();
      await addRecommendedRateColumns();
      console.log("Migrations completed successfully!");
      return;
    } catch (error) {
      console.error(`Migration attempt ${attempt} failed:`, error);
      if (attempt < retries) {
        console.log("Retrying...");
        await new Promise((resolve) => setTimeout(resolve, 5000));
      } else {
        console.error("All migration attempts failed.");
        process.exit(1);
      }
    }
  }
}

if (require.main === module) {
  runMigrationsWithRetry();
}


export default { createTables, dropTables, addRecommendedRateColumns };
